*数据库作业
讲解：

在了解了redis所依赖的核心技术和卓越性能之后，我们来通过一个具体的金融行业场景
应用来看一下redis应用难题及其解决方案。

我们知道对于金融行业，更高的峰值处理能力，与更低的业务延迟成为核心需求之一。

首先为了提高处理能力速度，人们开始引入缓存技术部署在网络模型上。
这个广义的cache使得某个用户的访问数据被暂存从而在其他用户访问的时候可以快速响应。
这个缓存可以进行一个全链路的部署。



**缓存的产生与发展（几句话带过）

国外有很多很有名且很好用的缓存技术产品例如 Nginx，属于 HTTP 和方向代理服务器，
是由俄罗斯某站点开发，2004 年发布了第一版本，其特点在于稳定性高、系统资源消耗
低，俄罗斯国内各大型的入口网站都在使用该技术，在美国很多虚拟主机行业
也在使用该技术，其并发能力强的特点在同类技术

Cache 是一个智能化的产品，当 html 页面、JS 脚本、图片等资源被首次访
问时会已副本的形式保存在服务器与客户端之间，当用户访问请求同一个资源
信息时，Cache 会自动根据相应机制判定资源是否更新，若无更新，则直接读取
本地信息返回客户端，若服务端标明资源有更新时，先从服务器端更新资源后
返回客户端,通过这种减少客户端与服务器端访问次数的方法从而达到节约带宽
和提高响应速度的目的。Cache 的主要作用表现为减少网络资源消耗、减少网络
延迟、减小服务器的请求压力、增强系统可用性。

缓存位与每个客户端 Client 的本地硬盘内或本地浏览器的内存中，这样优势
很明显：
访问容易且高效，避免了其他资源消耗，但劣势也是显而易见的：数据资
源只能存在于一个 Client 的本地硬盘内，独立于浏览器而存在，因此不能被更多
客户端共享。

给客户端 A 同时保留一个该请求的备份，那么在客户端 B 或
者 C 请求同一个源服务器的资源时，首先发往中间服务器，中间服务器根据相
应规则与访问控制列表去匹配，若匹配成功，则无需访问源服务器而能直接并
快速响应客户端请求，我们称这种中间服务器模式为代理缓存

反向代理服务器会向其后面对应的一台
或多台负载应用服务器，根据各服务器负载情况，动态的将请求发给合适的负
载服务器，以减少源服务器负载、保障源服务器的安全，同时还能完成源服务
器的负载均衡，在整个请求传输过程中，反向代理服务器可以理解为一个配备
有大容量内存和高速磁盘的智能路由器，负责匹配请求信息，若请求信息为静
态数据时，则可直接返回，若请求信息含有动态信息，则需要保持客户请求会
话的同时，智能获取动态信息后返回客户请求
请求动态数据反向代理要维持两个方向的会话的连接，会造成一定的网络资源消耗

应用层：代码逻辑和缓存策略实现对数据的内存存储
系统层：cache库对对常会且耗费资源的数据缓存起来，不过主要更新资源
费点功夫；
数据库层：内存数据库


这样的场景需求对于 Redis 来讲很简单，即使你的用户量有上百万或者数据
变动频率为百万/分钟，这都不成问题：
//登记新综合实力评分记录
ZADD leaderboard <score> <userid>
//获取综合实力排名前 100 的排行榜
ZREVRANGE leaderboard 0 99。
//获取某用户的全服务器综合实力排名
ZRANK leaderboard <userid>


**redis存在的问题（一分钟）

作为第二数据库需要考虑与第一数据库的一致性问题
（1）持久化不成熟，快照文件必然面临数据丢失，AOF 很影响性能；
（2）存储成本高，纯内存操作，不适合海量数据；
（3）注重内存容量规划；
（4）架构扩展不是很简单。

先来看一个 Redis 的系统表现：Redis 在物理内存上使用比较多，但还没有
超过服务器的实际物理内存总容量时，服务器就已经出现不稳定甚至崩溃的现
象。曾经以为这种风险是由于同一个物理机上的多个 Redis 实例同时触发持久化
的 BGSAVE 而导致瞬间 Fork 出多个 redis 进程，造成内存占用加倍而导致的。
后来经过研究发现这种不稳地现象是由于 Redis 的持久化使用了 Buffer IO 造成
的，即 Redis 持久化文件操作都是基于物理内存的 Page Cache，而大多数数据库
系统往往为了维护一个数据的 Cache 会使用 Direct IO 来绕过这层 Page Cache，
伴随数据量的增大，Redis 持久化文件会越来越大，尤其是快照文件会比 AOF
文件大数倍，在对此文件进行读写操作时，磁盘文件中的数据都会被加载到物
理内存中作为操作系统对该文件的一层 Cache，而这层 Cache 的数据与 Redis 内
存中管理的数据实际是重复存储的，虽然内核在物理内存紧张时会做 Page Cache
的剔除工作，但内核很可能认为某块 Page Cache 更重要，而让你的进程开始
Swap ,这时你的系统就会开始出现不稳定或者崩溃了。




**Redis 复制的改进思路（一分钟）

扩容
Redis 给出了一种叫做 Presharding 的方案来解决动态扩容和数据分区的问
题，就是在同一台机器上部署多个 Redis 实例的方式，当出现容量不足的情况时，
就把多个实例拆分到不同的物理机器上，完成实际的扩容效果。
Redis 实例拆分处理步骤如下：
1、在新机器上启动好对应端口的 Redis 实例。
2、配置新端口为待迁移端口的从库。
3、待复制完成，与主库完成同步后，切换所有客户端配置到新的从库的端
口。
4、配置从库为新的主库。
5、移除老的端口实例。
6、重复上述过程迁移好所有的端口到指定服务器上。


上面分析 Redis 复制的主要缺陷在于没有增量复制，导致无法快速恢复解决
单点问题，那么对持久化方案做改进，是否能完成增量同步？
改进的持久化方案是首先写 Redis 的 AOF 文件，并对这个 AOF 文件按文件
大小进行自动分割滚动，同时关闭 Redis 的 Rewrite 命令，然后会在业务低峰时
间进行内存快照存储，并把当前的 AOF 文件位置一起写入到快照文件中，这样
我们可以使快照文件与 AOF 文件的位置保持一致性，这样我们得到了系统某一
时刻的内存快照，并且同时也能知道这一时刻对应的 AOF 文件的位置，那么当
从库发送同步命令时，我们首先会把快照文件发送给从库，然后从库会取出该
快照文件中存储的 AOF 文件位置，并将该位置发给主库，主库会随后发送该位
置之后的所有命令，以后的复制就都是这个位置之后的增量信息了，整体改进

**结合金融应用（2分钟）

因其自身具备实时性要求高、数据量大、并
发访问高和数据类型多而杂等特点，所以仅使用关系数据库是无法满足系统架
构要求的，那么结合内存数据库速度快、扩展性好的特点，设置内存数据库在
关系数据库前端来完成数据缓存处理是个不错的架构设计方案。内存数据库的
数据操作都是直接存放在内存里，相比磁盘操作的关系数据库来说，性能高出
很多，这一点正是互联网金融平台所急需的。













主从模式：
主数据库可以进行读写操作，当读写操作导致数据变化时会自动将数据同步给从数据库

* 从数据库一般都是只读的，并且接收主数据库同步过来的数据

* 一个master可以拥有多个slave，但是一个slave只能对应一个master

* slave挂了不影响其他slave的读和master的读和写，重新启动后会将数据从master同步过来

* master挂了以后，不影响slave的读，但redis不再提供写服务，master重启后redis将重新对外提供写服务

* master挂了以后，不会在slave节点中重新选一个master



我们还可以设置同步队列长度。队列长度（backlog)是主redis中的一个缓冲区，在与从redis断开连接期间，主redis会用这个缓冲区来缓存应该发给从redis的数据。这样的话，当从redis重新连接上之后，就不必重新全量同步数据，只需要同步这部分增量数据即可。

复制代码代码如下:

repl-backlog-size 1mb


如果主redis等了一段时间之后，还是无法连接到从redis，那么缓冲队列中的数据将被清理掉。我们可以设置主redis要等待的时间长度。如果设置为0，则表示永远不清理。默认是1个小时。

复制代码代码如下:

repl-backlog-ttl 3600


我们可以给众多的从redis设置优先级，在主redis持续工作不正常的情况，优先级高的从redis将会升级为主redis。而编号越小，优先级越高。比如一个主redis有三个从redis，优先级编号分别为10、100、25，那么编号为10的从redis将会被首先选中升级为主redis。当优先级被设置为0时，这个从redis将永远也不会被选中。默认的优先级为100。

复制代码代码如下:

slave-priority 100



**相关概念
Oracle 数据
AOF
RDB持久化设计
运算数据库
虚拟主机
虑负载均衡
网络的网关

客户端和服务端交互的内容是序列化后的数据，服务器为每个客户端建立与之对应的连接，
在应用层维护一系列状态保存在connection 中，connection 间相互无关联。在Redis中，
connection 通过redisClient 结构体实现。


**确定更新点
采用更新时间戳、有的采用checkpoint等来标识和记录更新点。
list 和 sorted set
BufferIO I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，
数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝
到应用程序的地址空间。缓存 I/O 有以下这些优点：
DirectIO 
pagecache其内容对应磁盘上的block。page cache的大小是动态变化的，可以扩大，
也可以在内存不足时缩小。cache缓存的存储设备被称为后备存储（backing store），
注意我们在block I/O一文中提到的：一个page通常包含多个block，这些block不一定是连续的。

：Memcached 本身不具备监听记录是否已
过期的功能，而是通过获取数据记录的时间戳信息，比对当前时间戳后来判定
记录是否过期，这种被动的技术被称之为 lazyexpiration，

内存数据库技术的进一步发展和成熟是在 1984 年

**Redis 为我们提供了四种持久化的方式，分别是：定时快照方式（snapshot）、
基于语句追加文件的方式（aof）、虚拟内存（vm）和 Diskstore。这四种方式根
据设计思路的不同可以分为两类，前两种方式主要是基于小数据量的磁盘落地
功能，即全部数据内存化；后两种方式是基于大数据量的数据存储，不过目前
后两种模式仍在实验阶段，并且 vm 模式已经被作者放弃，所以实际的使用过程
中，目前最常用的仅前两种，下面我们对这两种模式做分别介绍：
定时快照（snapshot）又称之为 RDB，就是按照事先约定好的时间频度，将
增量的 redis 存储数据以快照文件的形式存储在磁盘介质上的方式；AOF 全称是
Appendonly file，直译就是附加文件，实现原理就是 redis 把数据变更指令都追加
在文件记录里，当重启 redis 时，读取文件内的所有操作指令并且按照记录顺序
执行一遍即可。
